'.source.gfm':

  '`code`':
    'prefix': 'lia.code.inline'
    'body': '`${1:code}`'
    'description': """
      Inline `code` has `back-ticks around` it.
    """
    'descriptionMoreURL': 'http://www.google.de'
    'leftLabelHTML': '<span style="color:#ff0">ðŸ’»</span>'


  '```lang ... ```':
    'prefix': 'lia.code.block'
    'body': """
      ```${1:javascript}
      ${2:var s = "JavaScript syntax highlighting";
      alert(s);}
      ```
    """
    'description': """
      To insert a code block with syntax highlight, enclose your code snippet with three back-ticks (```) that is followed by a language code. To search all language codes, visit the link below, but in most cases you can simply add either the name of the language or the typical file-ending.

      Examples:

        ```javascript
        var s = "JavaScript syntax highlighting";
        alert(s);
        s;
        ```

        ```python
        s = "Python syntax highlighting"
        print s
        ```

        ```
        No language indicated, so no syntax highlighting.
        But let's throw in a <b>tag</b>.
        ```
    """
    'descriptionMoreURL': 'https://highlightjs.org'
    'leftLabelHTML': '<span style="color:#ff0">ðŸ’»</span>'


  '```lang ... ``` <script>@code</script>':
    'prefix': 'lia.code.block.js'
    'body': """
      ```${1:javascript}
      ${2:var s = "JavaScript syntax highlighting";
      alert(s);
      s;}
      ```
      <script>${3:@code}</script>
    """
    'description': """
      To insert an executable and editable code block with syntax highlight, insert a common Markdown code block with a succeeding <script> tag. The macro @code is replaced with the current user input and gets evaluated in a try and chatch block. Using javascript you can also insert interpreters to other languages or access them. In these cases you will have to change the conntent of the script tag. To get an impression about the posibilities, click on the link below.
      The result of the script or the error are passed to a commandline like output beneath the code-block.

      Example:

        ```javascript
        var s = "JavaScript syntax highlighting";
        alert(s);
        ```
        <script>@code</script>
    """
    'descriptionMoreURL': 'https://liascript.github.io/course/?https://raw.githubusercontent.com/liaScript/docs/master/README.md'
    'leftLabelHTML': '<span style="color:#ff0">ðŸ’»</span>'


  '```lang +name ...```':
    'prefix': 'lia.code.block.name'
    'body': """
      ```${1:javascript} ${2:title.js}
      ${3:var s = "Named JavaScript syntax highlighting";
      alert(s);}
      ```
    """
    'description': """
      You can name your snippets by adding just after the language code. At default it will be visible, but by adding a plus (+) in front of your filename you can make this more expressable, whereby a minus (-) will hide it at first. In this way you can also group multiple files into a (executable) project.

      Examples:

        ```javascript    Visible.js
        alert("Visble JavaScript file";);
        ```

        ```javascript   +Visible.js
        alert("Also visible JavaScript file");
        ```

        ```javascript   -Hidden.js
        alert("Hidden JavaScript file on init");
        ```
    """
    'descriptionMoreURL': 'https://highlightjs.org'
    'leftLabelHTML': '<span style="color:#ff0">ðŸ’»</span>'


  '```lang +name ...``` <script>@code</script>':
    'prefix': 'lia.code.block.name.js'
    'body': """
      ```${1:javascript}   ${2:Filename.js}
      ${3:var s = "Named JavaScript syntax highlighting";
      alert(s);
      s;}
      ```
      <script>${4:@code}</script>
    """
    'description': """
      To insert a named and executable and code snippet. The macro @code is replaced with the current user input and gets evaluated in a try and chatch block. Using javascript you can also insert interpreters to other languages or access them. In these cases you will have to change the conntent of the script tag. To get an impression about the posibilities, click on the link below.
      The result of the script or the error are passed to a commandline like output beneath the code-block.

      Example:

        ```javascript   +Tile.js
        var s = "Visible JavaScript syntax highlighting";
        ```
        <script>@code</script>

        ```javascript   +Title.js
        var s = "Hidden JavaScript syntax highlighting";
        ```
        <script>@code</script>
    """
    'descriptionMoreURL': 'https://liascript.github.io/course/?https://raw.githubusercontent.com/liaScript/docs/master/README.md'
    'leftLabelHTML': '<span style="color:#ff0">ðŸ’»</span>'


  '```lang ... ``` <script> ... ':
    'prefix': 'lia.code.block.jsx'
    'body': """
      ```${1:javascript}
      ${2:var s = "JavaScript syntax highlighting";
      alert(s);}
      ```
      <script>
        try{
          eval(`@code`);
        } catch (e) {
          var log = e.stack.match(/((.*?):(.*))\\\\n.*?(:(\\\\d+):(\\\\d+)\\\\)\\\\n)/);
          var err_msg = new LiaError(log[1] + " =>  (" + log[4], 1);
          err_msg.add_detail(0, log[3], "error", log[5]-1, log[6]);
          throw err_msg;
        }
      </script>
    """
    'description': """
      This is an extended executable version of a code block, it shows how errors can be extracted and fed back by using LiaError to show inline errors, warnings, or information.
      If you are using a project and want to integrate more than one file into your execution, you will have to use the parametrized @code(int) macro, the integer is defined by the file order (@code defaults to 0).

      Example:

        ```javascript
        var s = "JavaScript syntax highlighting";
        alert(s);
        ```
        <script>
          try{
            eval(`@code`);  // <== code to evaluate
          } catch (e) {
            var log = e.stack.match(/((.*?):(.*))\\n.*?(:(\\d+):(\\d+)\\)\\n)/);
            var err_msg = new LiaError(log[1] + " =>  (" + log[4], 1);
            err_msg.add_detail(0, log[3], "error", log[5]-1, log[6]);
            throw err_msg;
          }
        </script>
    """
    'descriptionMoreURL': 'https://liascript.github.io/course/?https://raw.githubusercontent.com/liaScript/docs/master/README.md'
    'leftLabelHTML': '<span style="color:#ff0">ðŸ’»</span>'


  '<script>...@code...</script>':
    'prefix': 'lia.code.js'
    'body': """
      <script>
        try{
          eval(`@code`);
        } catch (e) {
          var log = e.stack.match(/((.*?):(.*))\\\\n.*?(:(\\\\d+):(\\\\d+)\\\\)\\\\n)/);
          var err_msg = new LiaError(log[1] + " =>  (" + log[4], 1);
          err_msg.add_detail(0, log[3], "error", log[5]-1, log[6]);
          throw err_msg;
        }
      </script>
    """
    'description': """
      This is an extended executable version of a code block, it shows how errors can be extracted and fed back by using LiaError to show inline errors, warnings, or information.
      If you are using a project and want to integrate more than one file into your execution, you will have to use the parametrized @code(int) macro, the integer is defined by the file order (@code defaults to 0).

      Example:

        <script>
          try{
            eval(`@code`); // code to be evaluated
          } catch (e) {
            // do some pattern matching to get the error string, the line number and column
            var log = e.stack.match(/((.*?):(.*))\\n.*?(:(\\d+):(\\d+)\\)\\n)/);

            // create a new LiaError object with
            // param1: an error message string
            // param2: add the number of files involved as int
            var err_msg = new LiaError(log[1] + " =>  (" + log[4], 1);

            // add as many information to your error message
            // param1: file id
            // param2: additional information string
            // param3: type, either "error", "info", or "warning"
            // param4: line number
            // param5: column number
            err_msg.add_detail(0, log[3], "error", log[5]-1, log[6]);

            throw err_msg;   // finally just throw it away
          }
        </script>
    """
    'descriptionMoreURL': 'https://liascript.github.io/course/?https://raw.githubusercontent.com/liaScript/docs/master/README.md'
    'leftLabelHTML': '<span style="color:#ff0">ðŸ’»</span>'


  '``` ... ``` ``` ... ``` ...':
    'prefix': 'lia.code.project'
    'body': """
      ``` ${1:js}     ${2:-EvalScript.js}
      ${3:let who = data.first_name + " " + data.last_name;

      if(data.online) {
        who + " is online"; \\}
      else {
        who + " is NOT online"; \\}}
      ```
      ``` ${4:json}    ${5:+Data.json}
      ${6:{
        "first_name" :  "Sammy",
        "last_name"  :  "Shark",
        "online"     :  true
      \\}}
      ```
      <script>
        ${7:// insert the JSON dataset into the local variable data
        let data = @code(1);

        // eval the script that uses this dataset
        eval(`@code(0)`);}
      </script>
    """
    'description': """
      If you want to create a project and thus seperate data and code into multiple files, simply write multiple code blocks in a sequence. To make them executable as a whole, simply add a script tag to the end and use the parametrized @code(id) macro to compose your project properly. The file id is defined by the order of code blocks.
      See the link below to see more examples.

      Example:

        ``` js     -EvalScript.js
        let who = data.first_name + " " + data.last_name;

        if(data.online) { who + " is online"; }
        else            { who + " is NOT online"; }
        ```
        ``` json    +Data.json
        { "first_name" :  "Sammy",
          "last_name"  :  "Shark",
          "online"     :  true   }
        ```
        <script>
          // insert the JSON dataset into the local variable data
          let data = @code(1);

          // eval the script that uses this dataset
          eval(`@code(0)`);
        </script>
    """
    'descriptionMoreURL': 'https://liascript.github.io/course/?https://raw.githubusercontent.com/liaScript/docs/master/README.md'
    'leftLabelHTML': '<span style="color:#ff0">ðŸ’»</span>'
